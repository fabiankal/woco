---
title: "Work and Corona Dashboard"
output: flexdashboard::flex_dashboard
runtime: shiny
---

```{r global, include=FALSE}
library(plotly)
library(tidyr)
library(dplyr)
library(rlang)
library(stringr)
# load data in 'global' chunk so it can be shared by all users of the dashboard
data <-readr::read_csv("https://raw.githubusercontent.com/fabiankal/woco/master/output/tables/export_shiny_data.csv")

data_shares <-readr::read_csv("https://raw.githubusercontent.com/fabiankal/woco/master/output/tables/export_shiny_data_shares.csv")

data_labels <-readr::read_csv("https://raw.githubusercontent.com/fabiankal/woco/master/output/tables/grouped_labels.csv")

data_varlab <-readr::read_csv("https://raw.githubusercontent.com/fabiankal/woco/master/output/tables/varlabels.csv")


#epidf = read.delim("Y:/Wirtschaftssoziologie/Corona/Corona_Panel_Analyse/data/raw/CovidFaelle_Timeline.csv", sep=";", header=TRUE)
epidf       <-readr::read_csv("https://raw.githubusercontent.com/fabiankal/woco/master/output/tables/CovidFaelle_Timeline.csv")

my_autocomplete_list <- data_varlab$labels[data_varlab$variable %in% unique(data$variable)]

hlinedata = data.frame(x = c("16.03.2020",
                             "14.04.2020",
                             "15.05.2020",
                             "15.05.2020",
                             "24.07.2020",
                             "21.09.2020",
                             "03.11.2020",
                             "17.11.2020",
                             "07.12.2020",
                             "26.12.2020",
                             "25.01.2021",
                             "08.02.2021",
                             "01.04.2021",
                             "03.05.2021",
                             "19.05.2021",
                             "01.07.2021"),
                     label_en=c("Lockdown",
                             "Easing of\nmeasurments",
                             "Reopening\nrestaurants",
                             "Easing of mask rules",
                             "Mask rules\nnew",
                             "Closing hour",
                             "Nightly\ncurfew",
                             "Lockdown\n",
                             "Reop.\ncommerce",
                             "Lock-\ndown",
                             "FFP2-\nmasks",
                             "Reopening",
                             "Lockdown\neast",
                             "Reopening\neast",
                             "Reopening",
                             "Easing of mask rules"),
                      label_de=c("Lockdown",
                             "Erste\nÖffnungen",
                             "Gastro-\nöffnung",
                             "Lockerung\nMasken",
                             "Maskenpflicht\nneu",
                             "Sperrstunde",
                             "Ausgangs-\nbeschränkungen",
                             "Lockdown",
                             "Öffnung\nHandel",
                             "Lockdown",
                             "FFP2-\nMasken",
                             "Öffnung",
                             "Lockdown\nOst",
                             "Öffnung\nOst",
                             "Öffnung",
                             "Lockerung\nMasken"),
                       y = c(1.1,1.1,1.1,1.1,1.1,
                             1.1,1.1,1.1,1.1,1.1,
                             1.1,1.1,1.1,1.1,1.1,
                             1.1))

hlinedata$x<-as.Date(hlinedata$x,"%d.%m.%Y")


# Add vertical line(s) at position x to plotly plot p
# Additional arguments: color, width (px), dash ('solid','dot', 'dash', etc)
# See https://plotly.com/r/reference/#layout-shapes-items-shape-line
add_vline = function(p, x, ...) {

  if(!is.null(p$x$layoutAttrs)){
      index <- unname(which(sapply(p$x$layoutAttrs, function(x) 
  !is.null(x$shapes))))
    } else {
      index <- integer()
    }

    l_shape = list(
      type = "line",
      y0 = 0, y1 = 1, yref = "paper", # i.e. y as a proportion of visible region
      x0 = x, x1 = x,
      line = list(
        ...
      ),
      layer = "below"
    )

    if(length(index) > 0){
      shapes <- p$x$layoutAttrs[[index]]$shapes
      shapes[[length(shapes) + 1]] <- l_shape
      p$x$layoutAttrs[[index]]$shapes <- shapes
    } else {
      p <- plotly::layout(
        p = p,
        shapes = list(l_shape)
      )
    }
   p
}

epidf_rc = epidf %>% filter(BundeslandID==10) %>% rename(daily_inf = names(epidf)[5],
                                                         daily_inf_7T = names(epidf)[7])

epidf_rc$time = as.Date(str_split(string = epidf_rc$Time, 
                        pattern = "[[:space:]]", 
                        simplify = TRUE)[, 1],
                        "%d.%m.%Y")


```

Mean plots
=======================================================================

Column {.sidebar}
-----------------------------------------------------------------------

Choose wisely.

```{r}
selectizeInput(
    inputId = 'variables',
    label = 'Variablen',
    choices = my_autocomplete_list,
    selected = my_autocomplete_list[2],
    multiple = TRUE, # allow for multiple inputs
    options = list(create = FALSE), # if TRUE, allows newly created inputs
  )
selectInput("groupby", label = "Gruppierung (der ersten Variable)",
            choices = c("Keine","Gender", "Age", "Education", "Region","Income"), selected = "Keine")

checkboxInput(inputId = 'confidence', label = "95% Konfidenzintervalle", value = FALSE)
checkboxInput(inputId = 'incidence', label = "7-Tages Inzidenz", value = FALSE)
checkboxInput(inputId = 'relevantdates', label = "Relevante Ergeignisse", value = FALSE)

# sliderInput("bw_adjust", label = "Bandwidth adjustment:",
#             min = 0.2, max = 2, value = 1, step = 0.2)

```

Column
-----------------------------------------------------------------------

### Plot averages per wave {data-height=450}

```{r}

#output$out1 <- renderPrint(input$relevantdates)
#verbatimTextOutput('out1')

# output$out1 <- renderPrint({data %>% select(wavedate,variable,mean_measurement,ymax_mean,ymin_mean) %>% 
#     distinct(wavedate,variable, .keep_all = TRUE) %>% 
#     filter(variable %in% input$variables) %>%  
#     pivot_wider(id_cols = c(wavedate,variable),names_from=variable, values_from=c(mean_measurement,ymax_mean,ymin_mean), names_glue = "{variable}_{.value}")})
# verbatimTextOutput('out1')

#eventReactive(input$groupby, { })

# renderPlotly({
# dt <- data.frame(x = 1:10, y = rnorm(10))    
# annotation <- list(yref = 'paper', xref = "x", y = 0, x = 2, text = "annotation")
# plot_ly(type = "scatter", mode = "lines") %>% add_trace(x = dt$x, y = dt$y, mode = "lines") %>% layout(annotations= list(annotation))%>% add_vline(hlinedata$x)
# })

renderPlotly({
  
  inputvariables <- data_varlab$variable[data_varlab$labels %in% input$variables]
  
  data2 = data %>% select(wavedate,variable,groupby,mean_measurement,ymax,ymin,scales) %>%
    distinct(wavedate,variable, .keep_all = TRUE) %>%
    filter(variable %in% inputvariables & groupby=="all") %>% left_join(data_varlab,by=c("variable"))
  
  #%>%
    #pivot_wider(id_cols = c(wavedate,variable),names_from=variable, values_from=c(mean_measurement,ymax_mean,ymin_mean), names_glue = "{variable}_{.value}")
  
  p <- data2 %>%
  plot_ly(x = ~wavedate, y= ~mean_measurement,type = 'scatter',mode = 'lines+markers',linetype=~labels)
  p <- p %>% layout(title = "",
         xaxis = list(title = ""),
         yaxis = list (title = ""),
         legend = list(orientation = 'h')#,
         #annotations = list(text = paste(text),
         #                   font = list(size = 12,color='black'),
         #                   showarrow = FALSE,
         #                   xref = 'paper', x = 0,
         #                   yref = 'paper', y = -0.1,
         #                   xanchor='left', yanchor='auto', xshift=0, yshift=0)
         )
  
  
  
  if(input$relevantdates)
  {
    for(i in 1:length(hlinedata$x))
      {
      p <- p %>% add_trace(x = hlinedata$x[i],y= ~mean_measurement, type = 'scatter', mode = 'lines',
                        line = list(color = "red", dash = "dash"),
                        text = hlinedata$label_de[i],showlegend = F,inherit = FALSE)
      }
  }
  if(input$incidence)
  {
    p <- p %>% add_trace(x = ~epidf_rc$time, y = ~epidf_rc$daily_inf, type = 'scatter', mode = 'none', name = 'Incidence',yaxis = "y2", fill = 'tozeroy', inherit = FALSE) %>% layout(yaxis2 = list(overlaying = "y", side = "right"))
  }
  if(input$confidence)
  {
     p <- p %>% error_y = list(type = "data",
                    symmetric = FALSE,
                    array = c(~ymax),arrayminus = c(~ymin),
                    orientation = "v",
                    type = "bar")
  }
  p
#   fig <- plot_ly(x = ~epidf_rc$time, y = ~epidf_rc$daily_inf, type = 'scatter', mode = 'lines', name = 'Fair cut',yaxis = "y2", fill = 'tozeroy')
# fig
  
})



#tags$a("The scale of this variable goes from ",tags$strong("X")," to.",tags$strong("Y"))

#p %>% layout(shapes = list(add_vline(hlinedata$x)))
# geom_area(data = epidf_rc %>% filter(time<as.Date('2021-04-20')), aes(x = time, y = daily_inf/10000, fill="lightgrey"), 
```

### {data-height=100}
```{r}
#output$out1 <- renderPrint(input$variables)
#verbatimTextOutput('out1')

#get a reactive (text) variable
myval <- reactiveValues()

 #Observe changes in variables (will run when variables change)
  observeEvent(input$variables, {
    
    inputvariables <- data_varlab$variable[data_varlab$labels %in% input$variables]
    
    data2 = data %>% select(wavedate,variable,groupby,mean_measurement,ymax,ymin,scales) %>%
    distinct(wavedate,variable, .keep_all = TRUE) %>%
    filter(variable %in% inputvariables & groupby=="all") #%>%
    #pivot_wider(id_cols = c(wavedate,variable),names_from=variable, values_from=c(mean_measurement,ymax_mean,ymin_mean), names_glue = "{variable}_{.value}")
  
  variables=0
  labels_st=0
  labels_en=0
  labels_ms=0
  labeln_st=0
  labeln_en=0
  text=0
  k=0
  
data_labels$wn[is.na(data_labels$wn)]<-"nown"
data_labels$ka[is.na(data_labels$ka)]<-"noka"
data_labels$nown="no WN option"
data_labels$noka="no KA option"
  
  for(i in unique(data2$scales))
      {
      k=k+1
       variables[k]=paste(data_varlab$labels[data_varlab$variable %in% unique(data2$variable[data2$scales==i])],sep=", ",collapse=", ")
       labeln_st[k]=paste(data_labels %>% filter(scales==i) %>% 
                            select(min) %>% distinct()-
                          data_labels %>% filter(scales==i) %>% 
                            select(min) %>% distinct(),sep=", ",collapse=", ")
       labels_st[k]=paste(data_labels %>% filter(scales==i) %>% 
                            select(V1) %>% distinct(),sep=", ",collapse=", ")
       labeln_en[k]=paste(data_labels %>% filter(scales==i) %>% 
                            select(max) %>% distinct()-
                          data_labels %>% filter(scales==i) %>% 
                            select(min) %>% distinct(),sep=", ",collapse=", ")
       labels_en[k]=paste(data_labels %>% filter(scales==i) %>% 
                            select(paste('V',data_labels %>% filter(scales==i) %>% select(scalenumber) %>% distinct(),sep="")) %>%
                            distinct(),sep=", ",collapse=", ")
       labels_ms[k]=paste(data_labels %>% filter(scales==i)  %>% 
                            select(paste(data_labels %>% filter(scales==i) %>% select(wn) %>% distinct())) %>% 
                            distinct(),
                          data_labels %>% filter(scales==i)  %>% 
                            select(paste(data_labels %>% filter(scales==i) %>% select(ka) %>% distinct())) %>% 
                            distinct(),
                          sep=", ",collapse=", ")
       if(data_labels %>% filter(scales==i) %>% select(rev) %>% distinct()=="0") 
         {
         text[k]=paste('The scale of variable(s)', variables[k], 'goes from',labeln_st[k],'=',labels_st[k],'to',labeln_en[k],'=',labels_en[k],'. Missing values:',labels_ms[k], sep=" ", collapse=" ")
         }
       else
         {
         text[k]=paste('The scale of variable(s)', variables[k], 'goes from',labeln_st[k],'=',labels_en[k],'to',labeln_en[k],'=',labels_st[k],'. Missing values:',labels_ms[k], sep=" ", collapse=" ")
         }
  }
    
     myval$calc <- text #write text in dynamic variable

  })

output$selected_var <- renderUI({
   HTML(paste(myval$calc, collapse="<br/>"))
  })

htmlOutput("selected_var")

```

### Show averages by group {data-height=450}

```{r}
#output$out1 <- renderPrint(input$groupby)
#verbatimTextOutput('out1')

# data3 = data %>% select(wavedate,variable,groupby,subgroup,mean_measurement,ymax,ymin) %>%
#     filter(variable %in% test2) %>%
#     filter(case_when(test=="Gender"~ groupby=="ge",
#                test=="Age"~ groupby=="ag"))

renderPlotly({
  
  inputvariables <- data_varlab$variable[data_varlab$labels %in% input$variables]

  data3 = data %>% select(wavedate,variable,groupby,subgroup,mean_measurement,ymax,ymin) %>%
    filter(variable %in% inputvariables[1]) %>%
    filter(case_when(input$groupby=="Gender"~ groupby=="ge",
                     input$groupby=="Age"~ groupby=="ag",
                     input$groupby=="Education"~ groupby=="ed",
                     input$groupby=="Region"~ groupby=="bl",
                     input$groupby=="Income"~ groupby=="hi"))

  p <- data3 %>%
  plot_ly(x = ~wavedate, y= ~mean_measurement,type = 'scatter', mode = 'lines+markers',linetype=~subgroup)
  p <- p %>% layout(title = "",
         xaxis = list(title = ""),
         yaxis = list (title = ""),
         legend = list(orientation = 'h'))
  p
})

```

Share plots
=======================================================================

Column {.sidebar}
-----------------------------------------------------------------------

Choose wisely.

```{r}
selectInput(
    inputId = 'var_shares',
    label = 'Variablen',
    choices = my_autocomplete_list,
    selected = my_autocomplete_list[1],
    multiple = FALSE, # allow for multiple inputs
    #options = list(create = FALSE), # if TRUE, allows newly created inputs
  )

```

Column
-----------------------------------------------------------------------

### Plots with shares

```{r}

renderPlotly({
  
  inputvariable_shares <- data_varlab$variable[data_varlab$labels %in% input$var_shares]
  
  data3 = data_shares %>% select(wavedate,variable,measurement,prop) %>%
    filter(variable %in% inputvariable_shares) 
  
  p <- ggplot(data3, aes(fill=measurement,x=wavedate, y=prop)) + 
    geom_area(position="stack", show.legend = TRUE,stat = "identity",colour="white",alpha=.8) + #geom_bar width=0.7
    geom_point(position=position_stack(),colour="white") +
    #geom_text(aes(label=round(prop*100, digits = 0)), position=position_stack(vjust=0.5), color="black", size=2) +
    scale_fill_brewer(palette = "RdYlBu", direction=1) +  #alternative:Blues
    labs(y = "Prozent", x= "",fill="") +
    scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
    scale_x_date(date_breaks = "2 month",date_labels = "%b-%y",guide = guide_axis(n.dodge = 2))
    theme(legend.position="bottom") + 
    guides(fill=guide_legend(ncol=5,nrow=1,byrow=TRUE)) 

  ggplotly(p)
  # p <- data3 %>%
  # plot_ly(x = ~wavedate, y= ~prop,type = 'bar',color = ~measurement,barmode = 'stack')
  # p <- p %>% layout(title = "Shares",
  #        xaxis = list(title = ""),
  #        yaxis = list (title = ""),
  #        legend = list(orientation = 'h'))
  
  
})

```